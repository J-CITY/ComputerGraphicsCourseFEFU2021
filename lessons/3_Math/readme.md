Векторы

Длина вектора: `|v| = sqrt(x*x + y*y + ...)`

Скаларное произведение `v*c = v.x*c.x + ...`

Векторное умножение определено только для 3D-пространства, в качестве входных данных принимает два непараллельных вектора и создает третий вектор, ортогональный обоим входным векторам. Если оба входных вектора также ортогональны друг другу, то в результате их векторного произведения мы получим 3 взаимно-ортогональных вектора (это нам пригодится на следующих уроках). На следующем рисунке показано, как это выглядит в 3D-пространстве:

`A x B = (Ay*Bz-Az*By; Az*Bx - Ax*Bz; Ax*By-Ay*Bx)`



Вспомним умножение метриц и векторов

Строка на столбец, есть сумма произведений соответсвтующих элементов

```
|q w e r|   |z|   |qz + wx + ec + rv|
|t y u i| * |x| = |tz + yx + uc + iv|
|o p a s|   |c|   |oz + px + ac + sv|
|d f g h|   |v|   |dz + fx + gc + hv|
```

|z x c v| - координата, которую преобразовываем

Все координаты пердстваленны в виде (x y z w)

w - некоторое вещественное число

Для простоты

Если w == 1, то вектор (x, y, z, 1) - это позиция в пространстве.

Если же w == 0, то вектор (x, y, z, 0) - это направление.

Матрица переноса (Transform)

```
|1 0 0 X|
|0 1 0 Y|
|0 0 1 Z|
|0 0 0 1|
```

X, Y, Z - координаты, которые прибавятся к нашей позиции

Матрица масштабирования (Scale)

```
|X 0 0 0|
|0 Y 0 0|
|0 0 Z 0|
|0 0 0 1|
```

Матрица поворота (Rotation)

Любое вращение в трехмерном пространстве может быть представлено как композиция поворотов вокруг трех ортогональных осей. Этой композиции соответствует матрица, равная произведению соответствующих трех матриц поворота.

Поворот вокруг оси X на угол a
```
|1 0      0        0|
|0 cos(a) -sin(a)  0|
|0 sina(a) cos(a)  0|
|0 0       0       1|
```


Поворот вокруг оси Y на угол a
```
|cos(a0)  0  sin(a) 0|
|0        1  0      0|
|-sina(a) 0  cos(a) 0|
|0        0  0      1|
```

Поворот вокруг оси Z на угол a
```
|cos(a0) -sin(a) 0  0|
|sin(a0) cos(a)  0  0|
|0       0       1  0|
|0       0       0  1|
```

Таким образом, изменения веткора равно

!Здесь важен порядок

newVec = Transform * Rotation * Scale * oldVec

В КГ мы работаем с несколькими системами координат
```
          Model mat       View mat         Projection
Локальная ->       Мировая ->     Камеры ->           Our "Image"
```

`Model mat` - комбинация переноса, скейла и поворота
`View mat` - получаем через lookAt
`Projection` - матрица проекции

Локальная - центр отображаемого объекта
Мировая - центр мира
Камеры - центр в аозиции камеры

Как переместить камеру?? - функцией lookAt(from, to, worldUp)

lookAt
1 - Вычисляем переднюю ось
forward = Normalize(from - to)

2 - Вычисляем right вектор
Декартовые системы координат - 3 еденичных вектора
Двы мы знаем (up и froward) - вычисляем 3й
right = crossProduct(randomVec, forward) // randomVec может быть worldUp
! Вектора следует нормолизовать

3 - Вычисляем up вектор (аналогично)
up = crossProduct(forward, right); 

4 - Формируем матрицу 4x4
Строка 1: заменить первые три коэффициента строки координатами right вектора
Строка 2: заменить первые три коэффициента строки координатами вектора up
Строка 3: заменить первые три коэффициента строки координатами forward вектора
Строка 4: заменить первые три коэффициента строки координатами from точки.

## Поворот камеры

Чтобы посмотреть вокруг сцены, мы должны изменить вектор Front камеры

Углы Эйлера — это три значения, которые могут представлять любое вращение в 3D-пространстве, определенные.

pitch — это угловое движение объекта относительно главной поперечной оси инерции (величина того, насколько мы смотрим вверх или вниз) — изображен в первой части картинки.

yaw — это угловые движения объекта относительно вертикальной оси, а также небольшие изменения курса вправо или влево — изображено во второй части картинки.

roll — это поворот объекта вокруг его продольной оси (он используется в камерах космического полёта) — изображен в третьей части картинки.

### Quaternions

Набор из 4 чисел [x y z w], который представляет вращение следующим образом:

x = RotationAxis.x * sin(RotationAngle / 2)
y = RotationAxis.y * sin(RotationAngle / 2)
z = RotationAxis.z * sin(RotationAngle / 2)
w = cos(RotationAngle / 2)

### Note

PS Чтобы в opengl в терхмерном пространстве все отображалось корректно, нужно включить Z буффер
// Включить тест глубины
glEnable(GL_DEPTH_TEST);

// Фрагмент будет выводиться только в том, случае, если он находится ближе к камере, чем предыдущий
glDepthFunc(GL_LESS);


Итак, теперь мы находимся в пространстве камеры. Но сцена будет выглядеть не естественно.
Чтобы это исправить нужно задать проекцию.

## Ортографическая проекция
Матрица ортографической проекции определяет кубообразную усеченную пирамиду видимости, задающую пространство отсечения, в котором отсекается каждая вершина, лежащая вне этого прямоугольника. При создании матрицы ортографической проекции мы задаем ширину, высоту и длину данной пирамиды.

Матрица ортографической проекции напрямую отображает координаты на двумерную плоскость, являющуюся вашим экраном, но в действительности такая прямая проекция предоставляет нереалистичные результаты, поскольку она не учитывает перспективу. 

## Перспективная проекция

Матрица проекции отображает диапазон, задаваемый усеченной пирамидой, в отсеченное пространство, и также манипулирует w-значением каждой координаты вершины таким образом, что чем дальше координата вершины находится от зрителя, тем больше становится w-компонента

Mat4 perspective(fow, ratio, near, far)

fov - обозначает поле зрения и задает размер видового пространства. Для реалистичного вида он обычно устанавливается равным 45 градусов, но если вы хотите получить что-то вроде doom-стиля, то можете установить более высокое значение. 

Второй параметр задает соотношение сторон, которое вычисляется путем деления ширины видового экрана на его высоту

Третий и четвертый параметры задают ближнюю и дальнюю плоскости пирамиды. Обычно мы устанавливаем ближнее расстояние равным значению 0.1, а дальнее — 100.0. Все вершины, лежащие между ближней и дальней плоскостями и внутри отсеченного пространства, будут визуализированы.


Она генерит матрицу
```
    |1/ratio/tan(fow/2) 0            0                                            0|
RES=|0                  1/tan(fow/2) 0                                            0|
    |0                  0            (-near-far)/(near-far) (2*far*near)/(near-far)|
    |0                  0            1                                            0|


ratio = witth/height

```


## Цветной кубик

Куб имеет 6 прямоугольных граней, но есть проблема - Opengl умеет рисовать только треугодльники.
То есть нужно отрисовать 12 треугольников. Задаем вершины точно также, как мы делали это для треугольника:

```
static const GLfloat g_vertex_buffer_data[] = {
    -1.0f,-1.0f,-1.0f, // Треугольник 1 : начало
    -1.0f,-1.0f, 1.0f,
    -1.0f, 1.0f, 1.0f, // Треугольник 1 : конец
    1.0f, 1.0f,-1.0f, // Треугольник 2 : начало
    -1.0f,-1.0f,-1.0f,
    -1.0f, 1.0f,-1.0f, // Треугольник 2 : конец
    1.0f,-1.0f, 1.0f,
    -1.0f,-1.0f,-1.0f,
    1.0f,-1.0f,-1.0f,
    1.0f, 1.0f,-1.0f,
    1.0f,-1.0f,-1.0f,
    -1.0f,-1.0f,-1.0f,
    -1.0f,-1.0f,-1.0f,
    -1.0f, 1.0f, 1.0f,
    -1.0f, 1.0f,-1.0f,
    1.0f,-1.0f, 1.0f,
    -1.0f,-1.0f, 1.0f,
    -1.0f,-1.0f,-1.0f,
    -1.0f, 1.0f, 1.0f,
    -1.0f,-1.0f, 1.0f,
    1.0f,-1.0f, 1.0f,
    1.0f, 1.0f, 1.0f,
    1.0f,-1.0f,-1.0f,
    1.0f, 1.0f,-1.0f,
    1.0f,-1.0f,-1.0f,
    1.0f, 1.0f, 1.0f,
    1.0f,-1.0f, 1.0f,
    1.0f, 1.0f, 1.0f,
    1.0f, 1.0f,-1.0f,
    -1.0f, 1.0f,-1.0f,
    1.0f, 1.0f, 1.0f,
    -1.0f, 1.0f,-1.0f,
    -1.0f, 1.0f, 1.0f,
    1.0f, 1.0f, 1.0f,
    -1.0f, 1.0f, 1.0f,
    1.0f,-1.0f, 1.0f
};
```

далее связываем массив с opengl, аналогично, как и треугольник

Далее рисуем треугольник

```
glDrawArrays(GL_TRIANGLES, 0, 12*3); 
```

Цвет задается аналогично для каждой вершины и аналогично связывается с opengl

!Важно

```
glVertexAttribPointer(
    1,                                // Атрибут. Здесь необязательно указывать 1, но главное, чтобы это значение совпадало с layout в шейдере..
    3,                                // Размер
    GL_FLOAT,                         // Тип
    GL_FALSE,                         // Нормализован?
    0,                                // Шаг
    (void*)0                          // Смещение
);
```

layout

```
// Не забывайте, что значение "1" здесь должно быть идентично значению атрибута в glVertexAttribPointer
layout(location = 1) in vec3 vertexColor;
```
