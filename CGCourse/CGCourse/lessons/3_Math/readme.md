Вспомним умножение метриц и векторов

Строка на столбец, есть сумма соответсвтующих элементов

```
|q w e r|   |z|   |qz + wx + ec + rv|
|t y u i| * |x| = |tz + yx + uc + iv|
|o p a s|   |c|   |oz + px + ac + sv|
|d f g h|   |v|   |dz + fx + gc + hv|
```

|z x c v| - координата, которую преобразовываем

Все координаты пердстваленны в виде (x y z w)

w - некоторое вещественное число

Для простоты

Если w == 1, то вектор (x, y, z, 1) - это позиция в пространстве.

Если же w == 0, то вектор (x, y, z, 0) - это направление.

Матрица переноса (Transform)

```
|1 0 0 X|
|0 1 0 Y|
|0 0 1 Z|
|0 0 0 1|
```

X, Y, Z - координаты, которые прибавятся к нашей позиции

Матрица масштабирования (Scale)

```
|X 0 0 0|
|0 Y 0 0|
|0 0 Z 0|
|0 0 0 1|
```

Матрица поворота (Rotation)

Любое вращение в трехмерном пространстве может быть представлено как композиция поворотов вокруг трех ортогональных осей. Этой композиции соответствует матрица, равная произведению соответствующих трех матриц поворота.

Поворот вокруг оси X на угол a
```
|1 0      0        0|
|0 cos(a) -sin(a)  0|
|0 sina(a) cos(a)  0|
|0 0       0       1|
```


Поворот вокруг оси Y на угол a
```
|cos(a0)  0  sin(a) 0|
|0        1  0      0|
|-sina(a) 0  cos(a) 0|
|0        0  0      1|
```

Поворот вокруг оси Z на угол a
```
|cos(a0) -sin(a) 0  0|
|sin(a0) cos(a)  0  0|
|0       0       1  0|
|0       0       0  1|
```

Таким образом, изменения веткора равно

!Здесь важен порядок

newVec = Transform * Rotation * Scale * oldVec

В КГ мы работаем с несколькими системами координат
```
          Model mat       View mat
Локальная ->       Мировая ->     Камеры
```
Локальная - центр отображаемого объекта
Мировая - центр мира
Камеры - центр в аозиции камеры

Как переместить камеру?? - функцией lookAt(from, to, worldUp)

lookAt
1 - Вычисляем переднюю ось
forward = Normalize(from - to)

2 - Вычисляем right вектор
Декартовые системы координат - 3 еденичных вектора
Двы мы знаем (up и froward) - вычисляем 3й
right = crossProduct(randomVec, forward) // randomVec может быть worldUp
! Вектора следует нормолизовать

3 - Вычисляем up вектор (аналогично)
up = crossProduct(forward, right); 

4 - Формируем матрицу 4x4
Строка 1: заменить первые три коэффициента строки координатами right вектора
Строка 2: заменить первые три коэффициента строки координатами вектора up
Строка 3: заменить первые три коэффициента строки координатами forward вектора
Строка 4: заменить первые три коэффициента строки координатами from точки.


Итак, теперь мы находимся в пространстве камеры. Но сцена будет выглядеть не естественно.
Чтобы это исправить нужно задать проекцию.

Для этого используем функцию perspective(fow, ratio, near, far)

Она генерит матрицу
```
    |1/ratio/tan(fow/2) 0            0                      0|
RES=|0                  1/tan(fow/2) 0                      0|
    |0                  0            -far/(far-near)       -1|
    |0                  0            -(far*near)/(far-near) 0|
```

PS Чтобы в opengl в терхмерном пространстве все отображалось корректно, нужно включить Z буффер
// Включить тест глубины
glEnable(GL_DEPTH_TEST);

// Фрагмент будет выводиться только в том, случае, если он находится ближе к камере, чем предыдущий
glDepthFunc(GL_LESS);



## Цветной кубик

Куб имеет 6 прямоугольных граней, но есть проблема - Opengl умеет рисовать только треугодльники.
То есть нужно отрисовать 12 треугольников. Задаем вершины точно также, как мы делали это для треугольника:

```
static const GLfloat g_vertex_buffer_data[] = {
    -1.0f,-1.0f,-1.0f, // Треугольник 1 : начало
    -1.0f,-1.0f, 1.0f,
    -1.0f, 1.0f, 1.0f, // Треугольник 1 : конец
    1.0f, 1.0f,-1.0f, // Треугольник 2 : начало
    -1.0f,-1.0f,-1.0f,
    -1.0f, 1.0f,-1.0f, // Треугольник 2 : конец
    1.0f,-1.0f, 1.0f,
    -1.0f,-1.0f,-1.0f,
    1.0f,-1.0f,-1.0f,
    1.0f, 1.0f,-1.0f,
    1.0f,-1.0f,-1.0f,
    -1.0f,-1.0f,-1.0f,
    -1.0f,-1.0f,-1.0f,
    -1.0f, 1.0f, 1.0f,
    -1.0f, 1.0f,-1.0f,
    1.0f,-1.0f, 1.0f,
    -1.0f,-1.0f, 1.0f,
    -1.0f,-1.0f,-1.0f,
    -1.0f, 1.0f, 1.0f,
    -1.0f,-1.0f, 1.0f,
    1.0f,-1.0f, 1.0f,
    1.0f, 1.0f, 1.0f,
    1.0f,-1.0f,-1.0f,
    1.0f, 1.0f,-1.0f,
    1.0f,-1.0f,-1.0f,
    1.0f, 1.0f, 1.0f,
    1.0f,-1.0f, 1.0f,
    1.0f, 1.0f, 1.0f,
    1.0f, 1.0f,-1.0f,
    -1.0f, 1.0f,-1.0f,
    1.0f, 1.0f, 1.0f,
    -1.0f, 1.0f,-1.0f,
    -1.0f, 1.0f, 1.0f,
    1.0f, 1.0f, 1.0f,
    -1.0f, 1.0f, 1.0f,
    1.0f,-1.0f, 1.0f
};
```

далее связываем массив с opengl, аналогично, как и треугольник

Далее рисуем треугольник

```
glDrawArrays(GL_TRIANGLES, 0, 12*3); 
```

Цвет задается аналогично для каждой вершины и аналогично связывается с opengl

!Важно

```
glVertexAttribPointer(
    1,                                // Атрибут. Здесь необязательно указывать 1, но главное, чтобы это значение совпадало с layout в шейдере..
    3,                                // Размер
    GL_FLOAT,                         // Тип
    GL_FALSE,                         // Нормализован?
    0,                                // Шаг
    (void*)0                          // Смещение
);
```

layout

```
// Не забывайте, что значение "1" здесь должно быть идентично значению атрибута в glVertexAttribPointer
layout(location = 1) in vec3 vertexColor;
```
